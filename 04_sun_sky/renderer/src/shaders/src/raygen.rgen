#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "bsdf.glsl"
#include "common.glsl"
#include "light.glsl"
#include "payload.glsl"
#include "push_constants.glsl"
#include "random.glsl"
#include "sampler.glsl"

layout(location = 0) rayPayloadEXT Prd prd;
layout(location = 1) rayPayloadEXT ShadowPrd shadowPrd;

// アンチエイリアスのためにpixelの位置をずらす
vec2 getCameraDelta() {
  vec2 delta = 2 * rnd2();
  if (delta.x < 1.0) {
    delta.x = sqrt(delta.x) - 1.0;
  } else {
    delta.x = 1.0 - sqrt(2.0 - delta.x);
  }
  if (delta.y < 1.0) {
    delta.y = sqrt(delta.y) - 1.0;
  } else {
    delta.y = 1.0 - sqrt(2.0 - delta.y);
  }
  delta *= 0.5;
  return delta;
}

float misWeightPowerHeuristic(float pdfA, float weightA, float pdfB,
                              float weightB) {
  return pow(weightA * pdfA, 2.0) / pow(weightA * pdfA + weightB * pdfB, 2.0);
}

void main() {
  init_random(0);
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 delta = getCameraDelta();
  vec2 inUV = (pixelCenter + delta) / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  d.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

  vec3 origin = pushConstants.cameraTranslate;
  vec3 direction = normalize(vec3(d.x, d.y, -2.0));
  direction = (pushConstants.cameraRotate * vec4(direction, 0.0)).xyz;
  float tmin = 0.001;
  float tmax = 100000.0;

  prd.depth = 0;
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);

  prd.miss = 0;
  while (true) {
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT,
                0xff, // mask
                0,    // sbtRecordOffset
                0,    // sbtRecordStride
                0,    // missIndex
                origin, tmin, direction, tmax,
                0 // payload location
    );

    prd.depth++;
    if (prd.miss == 1 || prd.depth > pushConstants.maxRecursionDepth) {
      break;
    }

    origin = prd.hitPosition;
    Material material = prd.material;

    float[DIMENSION] u = sampleRandom(prd.depth);

    float russianRouletteProbability = clamp(luminance(throughput), 0.0, 1.0);
    if (prd.depth > 0) {
      float p = u[0];
      if (p > russianRouletteProbability) {
        break;
      }
      throughput /= russianRouletteProbability;
    }

    float sunWeight = 0.0;
    if (pushConstants.sunEnabled == 1) {
      // sun
      vec3 sunStrength = getSunStrength();
      sunWeight = luminance(sunStrength);
      float[2] u2 = float[](rnd1(), rnd1());
      vec3 sunDirection = sampleSunDirection(u2);
      shadowPrd.shadow = 0;
      shadowPrd.attenuation = vec3(1.0);
      traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                  0xff, // mask
                  2,    // sbtRecordOffset
                  1,    // sbtRecordStride
                  1,    // missIndex
                  origin, tmin, sunDirection, tmax,
                  1 // payload location
      );
      if (shadowPrd.shadow == 0) {
        float sunPdf = getSunPdf(sunDirection);
        vec3 bsdfWeight;
        vec3 emissive;
        evalBsdfWeight(prd, material, -direction, sunDirection, bsdfWeight,
                       emissive);
        float bsdfPdf = evalBsdfPdf(prd, material, -direction, sunDirection);
        float misWeight =
            misWeightPowerHeuristic(sunPdf, sunWeight, bsdfPdf, 1.0);
        radiance += throughput * bsdfWeight * sunStrength *
                    shadowPrd.attenuation * misWeight;
      }
    }

    float[3] uu = float[3](u[1], u[2], u[3]);
    vec3 viewDirection = -direction;
    vec3 dir;
    vec3 weight;
    vec3 emissive;
    bool traceNext =
        sampleBsdf(uu, prd, material, viewDirection, dir, weight, emissive);
    float bsdfPdf = evalBsdfPdf(prd, material, viewDirection, dir);

    radiance += throughput * emissive;
    if (!traceNext) {
      break;
    }

    float sunPdf = 0.0;
    if (pushConstants.sunEnabled == 1) {
      if (isSunDirection(dir)) {
        shadowPrd.shadow = 0;
        shadowPrd.attenuation = vec3(1.0);
        traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                    0xff, // mask
                    2,    // sbtRecordOffset
                    1,    // sbtRecordStride
                    1,    // missIndex
                    origin, tmin, dir, tmax,
                    1 // payload location
        );
        if (shadowPrd.shadow == 0) {
          sunPdf = getSunPdf(dir);
        }
      }
    }

    float misWeight = misWeightPowerHeuristic(bsdfPdf, 1.0, sunPdf, sunWeight);

    direction = dir;
    throughput *= weight;
  }

  vec3 rgb = radiance;

  vec4 prev = imageLoad(storageReadImages[pushConstants.storageImageIndex],
                        ivec2(gl_LaunchIDEXT.xy));
  imageStore(storageWriteImages[pushConstants.storageImageIndex],
             ivec2(gl_LaunchIDEXT.xy), vec4(prev.rgb + rgb, 1.0));
}
