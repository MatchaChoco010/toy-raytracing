#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "../modules/bxdf/standard.glsl"
#include "../modules/common.glsl"
#include "../modules/light/sun.glsl"
#include "../modules/payload.glsl"
#include "../modules/random.glsl"
#include "../modules/sampler.glsl"

layout(location = 0) rayPayloadEXT Prd prd;
layout(location = 1) rayPayloadEXT ShadowPrd shadowPrd;

// アンチエイリアスのためにpixelの位置をずらす
vec2 getCameraDelta() {
  vec2 delta = 2 * vec2(rnd(), rnd());
  if (delta.x < 1.0) {
    delta.x = sqrt(delta.x) - 1.0;
  } else {
    delta.x = 1.0 - sqrt(2.0 - delta.x);
  }
  if (delta.y < 1.0) {
    delta.y = sqrt(delta.y) - 1.0;
  } else {
    delta.y = 1.0 - sqrt(2.0 - delta.y);
  }
  delta *= 0.5;
  return delta;
}

// カメラのレイの原点と方向を計算する
void setCameraRay(out vec3 origin, out vec3 direction) {
  ;
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 delta = getCameraDelta();
  vec2 inUV = (pixelCenter + delta) / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  d.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

  origin = pushConstants.cameraTranslate;
  direction =
      normalize(vec3(d.x, d.y, -1.0 / atan(pushConstants.cameraFov / 2.0)));
  direction = (pushConstants.cameraRotate * vec4(direction, 0.0)).xyz;
}

// MISの重みをパワーヒューリスティックスで計算する
float misWeightPowerHeuristic(float mainPdf, float[2] otherPdfs) {
  float otherPdfSum = 0.0;
  for (int i = 0; i < otherPdfs.length(); i++) {
    otherPdfSum += otherPdfs[i];
  }
  return pow(mainPdf, 2.0) / pow(otherPdfSum, 2.0);
}

void main() {
  init_random(0);

  vec3 origin;
  vec3 direction;
  setCameraRay(origin, direction);

  float tmin = 0.001;
  float tmax = 100000.0;

  prd.depth = 0;
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);

  while (true) {
    prd.miss = 0;
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT,
                0xff, // mask
                0,    // sbtRecordOffset
                0,    // sbtRecordStride
                0,    // missIndex
                origin, tmin, direction, tmax,
                0 // payload location
    );

    prd.depth++;

    // depth == 1のカメラレイで光源に当たった場合は、その光源の放射輝度を返す
    if (prd.depth == 1 && prd.miss == 1) {
      if (isSunDirection(direction)) {
        radiance += getSunStrength();
      }
    }

    if (prd.miss == 1 || prd.depth > pushConstants.maxRecursionDepth) {
      break;
    }

    origin = prd.hitPosition;
    Material material = prd.material;
    vec3 viewDirection = -direction;
    MaterialData materialData = getMaterialData(prd, material, viewDirection);

    float[6] u = SAMPLE_RANDOM(3, 6, 7)(prd.depth);

    float russianRouletteProbability = clamp(luminance(throughput), 0.0, 1.0);
    if (prd.depth > 0) {
      float p = u[0];
      if (p > russianRouletteProbability) {
        break;
      }
      throughput /= russianRouletteProbability;
    }

    float sunWeight = 0.0;
    if (pushConstants.sunEnabled == 1) {
      // sun
      vec3 sunStrength = getSunStrength();
      sunWeight = luminance(sunStrength);
      float[2] u2 = float[](u[1], u[2]);
      vec3 sunDirection = sampleSunDirection(u2);
      shadowPrd.shadow = 0;
      shadowPrd.transparent = vec3(1.0);
      traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                  0xff, // mask
                  2,    // sbtRecordOffset
                  1,    // sbtRecordStride
                  1,    // missIndex
                  origin, tmin, sunDirection, tmax,
                  1 // payload location
      );
      if (shadowPrd.shadow == 0) {
        float sunPdf = getSunPdf(sunDirection);
        vec3 bsdfWeight;
        vec3 emissive;
        evalStandardBsdf(prd, material, viewDirection, sunDirection, bsdfWeight,
                         emissive);
        float bsdfPdf =
            evalStandardPdf(prd, material, viewDirection, sunDirection);
        float misWeight =
            misWeightPowerHeuristic(sunPdf, float[](sunPdf, bsdfPdf));
        float cosTheta =
            max(dot(sunDirection, materialData.shadingNormal), 0.0);
        radiance += sunStrength * throughput * shadowPrd.transparent *
                    bsdfWeight * cosTheta * misWeight / sunPdf;
      }
    }

    float[3] uu = float[3](u[3], u[4], u[5]);
    vec3 dir;
    float cosTheta;
    vec3 bsdf;
    float bsdfPdf;
    vec3 emissive;
    bool traceNext = sampleStandardBsdf(uu, prd, material, viewDirection, dir,
                                        cosTheta, bsdf, bsdfPdf, emissive);

    radiance += throughput * emissive;
    if (!traceNext) {
      break;
    }

    float sunPdf = 0.0;
    if (pushConstants.sunEnabled == 1) {
      if (isSunDirection(dir)) {
        shadowPrd.shadow = 0;
        shadowPrd.transparent = vec3(1.0);
        traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                    0xff, // mask
                    2,    // sbtRecordOffset
                    1,    // sbtRecordStride
                    1,    // missIndex
                    origin, tmin, dir, tmax,
                    1 // payload location
        );
        if (shadowPrd.shadow == 0) {
          sunPdf = getSunPdf(dir);
        }
      }
    }

    float misWeight =
        misWeightPowerHeuristic(bsdfPdf, float[](sunPdf, bsdfPdf));

    direction = dir;
    throughput *= misWeight * bsdf * cosTheta / bsdfPdf;
  }

  vec3 rgb = radiance;

  vec4 prev = imageLoad(storageReadImages[pushConstants.storageImageIndex],
                        ivec2(gl_LaunchIDEXT.xy));
  imageStore(storageWriteImages[pushConstants.storageImageIndex],
             ivec2(gl_LaunchIDEXT.xy), vec4(prev.rgb + rgb, 1.0));
}
