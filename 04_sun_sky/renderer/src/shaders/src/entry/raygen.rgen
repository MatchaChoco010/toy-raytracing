#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "../modules/bxdf/standard.glsl"
#include "../modules/common.glsl"
#include "../modules/light/sun.glsl"
#include "../modules/payload.glsl"
#include "../modules/random.glsl"
#include "../modules/sampler.glsl"

layout(location = 0) rayPayloadEXT Prd prd;
layout(location = 1) rayPayloadEXT ShadowPrd shadowPrd;

// アンチエイリアスのためにpixelの位置をずらす
vec2 getCameraDelta() {
  vec2 delta = 2 * vec2(rnd(), rnd());
  if (delta.x < 1.0) {
    delta.x = sqrt(delta.x) - 1.0;
  } else {
    delta.x = 1.0 - sqrt(2.0 - delta.x);
  }
  if (delta.y < 1.0) {
    delta.y = sqrt(delta.y) - 1.0;
  } else {
    delta.y = 1.0 - sqrt(2.0 - delta.y);
  }
  delta *= 0.5;
  return delta;
}

// カメラのレイの原点と方向を計算する
void setCameraRay(out vec3 origin, out vec3 direction) {
  ;
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 delta = getCameraDelta();
  vec2 inUV = (pixelCenter + delta) / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  d.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

  origin = pushConstants.cameraTranslate;
  direction =
      normalize(vec3(d.x, d.y, -1.0 / atan(pushConstants.cameraFov / 2.0)));
  direction = (pushConstants.cameraRotate * vec4(direction, 0.0)).xyz;
}

// MISの重みをパワーヒューリスティックスで計算する
float misWeightPowerHeuristic(float pdfA, float weightA, float pdfB,
                              float weightB) {
  return pow(weightA * pdfA, 2.0) / pow(weightA * pdfA + weightB * pdfB, 2.0);
}

void main() {
  init_random(0);

  vec3 origin;
  vec3 direction;
  setCameraRay(origin, direction);

  float tmin = 0.001;
  float tmax = 100000.0;

  prd.depth = 0;
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);

  prd.miss = 0;
  while (true) {
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT,
                0xff, // mask
                0,    // sbtRecordOffset
                0,    // sbtRecordStride
                0,    // missIndex
                origin, tmin, direction, tmax,
                0 // payload location
    );

    prd.depth++;
    if (prd.miss == 1 || prd.depth > pushConstants.maxRecursionDepth) {
      break;
    }

    origin = prd.hitPosition;
    Material material = prd.material;

    float[6] u = SAMPLE_RANDOM(3, 6, 7)(prd.depth);

    float russianRouletteProbability = clamp(luminance(throughput), 0.0, 1.0);
    if (prd.depth > 0) {
      float p = u[0];
      if (p > russianRouletteProbability) {
        break;
      }
      throughput /= russianRouletteProbability;
    }

    float sunWeight = 0.0;
    if (pushConstants.sunEnabled == 1) {
      // sun
      vec3 sunStrength = getSunStrength();
      sunWeight = luminance(sunStrength);
      float[2] u2 = float[](u[1], u[2]);
      vec3 sunDirection = sampleSunDirection(u2);
      shadowPrd.shadow = 0;
      shadowPrd.attenuation = vec3(1.0);
      traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                  0xff, // mask
                  2,    // sbtRecordOffset
                  1,    // sbtRecordStride
                  1,    // missIndex
                  origin, tmin, sunDirection, tmax,
                  1 // payload location
      );
      if (shadowPrd.shadow == 0) {
        float sunPdf = getSunPdf(sunDirection);
        vec3 bsdfWeight;
        vec3 emissive;
        vec3 viewDirection = -direction;
        evalStandardBsdf(prd, material, viewDirection, sunDirection, bsdfWeight,
                         emissive);
        float bsdfPdf =
            evalStandardPdf(prd, material, viewDirection, sunDirection);
        float misWeight = misWeightPowerHeuristic(sunPdf, 1.0, bsdfPdf, 1.0);
        MaterialData materialData =
            getMaterialData(prd, material, viewDirection);
        float cosTheta =
            max(dot(sunDirection, materialData.shadingNormal), 0.0);
        radiance += throughput * bsdfWeight * cosTheta * sunStrength *
                    shadowPrd.attenuation * misWeight / sunPdf;
      }
    }

    float[3] uu = float[3](u[3], u[4], u[5]);
    vec3 viewDirection = -direction;
    vec3 dir;
    vec3 bsdf;
    float bsdfPdf;
    vec3 emissive;
    bool traceNext = sampleStandardBsdf(uu, prd, material, viewDirection, dir,
                                        bsdf, bsdfPdf, emissive);

    radiance += throughput * emissive;
    if (!traceNext) {
      break;
    }

    float sunPdf = 0.0;
    if (pushConstants.sunEnabled == 1) {
      if (isSunDirection(dir)) {
        shadowPrd.shadow = 0;
        shadowPrd.attenuation = vec3(1.0);
        traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                    0xff, // mask
                    2,    // sbtRecordOffset
                    1,    // sbtRecordStride
                    1,    // missIndex
                    origin, tmin, dir, tmax,
                    1 // payload location
        );
        if (shadowPrd.shadow == 0) {
          sunPdf = getSunPdf(dir);
        }
      }
    }

    float misWeight = misWeightPowerHeuristic(bsdfPdf, 1.0, sunPdf, 1.0);

    direction = dir;
    throughput *= misWeight * bsdf / bsdfPdf;
  }

  vec3 rgb = radiance;

  vec4 prev = imageLoad(storageReadImages[pushConstants.storageImageIndex],
                        ivec2(gl_LaunchIDEXT.xy));
  imageStore(storageWriteImages[pushConstants.storageImageIndex],
             ivec2(gl_LaunchIDEXT.xy), vec4(prev.rgb + rgb, 1.0));
}
