#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "../modules/bxdf/standard.glsl"
#include "../modules/common.glsl"
#include "../modules/light/sky.glsl"
#include "../modules/light/sun.glsl"
#include "../modules/payload.glsl"
#include "../modules/random.glsl"
#include "../modules/sampler.glsl"

layout(location = 0) rayPayloadEXT Prd prd;
layout(location = 1) rayPayloadEXT ShadowPrd shadowPrd;

// アンチエイリアスのためにpixelの位置をずらす
vec2 getCameraDelta() {
  // 最初のサンプルは中心に打つ
  if (pushConstants.sampleIndex == 0) {
    return vec2(0.0);
  }

  vec2 delta = 2 * vec2(rnd(), rnd());
  if (delta.x < 1.0) {
    delta.x = sqrt(delta.x) - 1.0;
  } else {
    delta.x = 1.0 - sqrt(2.0 - delta.x);
  }
  if (delta.y < 1.0) {
    delta.y = sqrt(delta.y) - 1.0;
  } else {
    delta.y = 1.0 - sqrt(2.0 - delta.y);
  }
  delta *= 0.5;
  return delta;
}

// SetCameraRayの返り値
struct SetCameraRayResult {
  vec3 origin;
  vec3 direction;
};

// カメラのレイの原点と方向を計算する
SetCameraRayResult setCameraRay() {
  SetCameraRayResult result;

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 delta = getCameraDelta();
  vec2 inUV = (pixelCenter + delta) / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  d.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

  result.origin = pushConstants.cameraTranslate;

  vec3 direction =
      normalize(vec3(d.x, d.y, -1.0 / atan(pushConstants.cameraFov / 2.0)));
  result.direction = (pushConstants.cameraRotate * vec4(direction, 0.0)).xyz;

  return result;
}

// MISの重みをパワーヒューリスティックスで計算する
float misWeightPowerHeuristic(float mainPdf, float[3] otherPdfs) {
  float otherPdf2Sum = 0.0;
  for (int i = 0; i < otherPdfs.length(); i++) {
    otherPdf2Sum += pow(otherPdfs[i], 1.0);
  }
  return pow(mainPdf, 1.0) / otherPdf2Sum;
}

void main() {
  init_random(0);

  SetCameraRayResult cam = setCameraRay();

  float tmin = 0.001;
  float tmax = 100000.0;

  prd.depth = 0;
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);
  vec3 origin = cam.origin;
  vec3 direction = cam.direction;

  vec3 outputNormal = vec3(0.0);
  vec3 outputBaseColor = vec3(0.0);

  while (true) {
    prd.miss = 0;
    traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                0xff, // mask
                0,    // sbtRecordOffset
                1,    // sbtRecordStride
                0,    // missIndex
                origin, tmin, direction, tmax,
                0 // payload location
    );

    prd.depth++;

    // カメラレイにskyとsunを表示する
    if (prd.depth == 1 && prd.miss == 1) {
      if (pushConstants.sunEnabled == 1 && isSunDirection(direction)) {
        radiance += throughput * getSunStrength();
      }
      if (pushConstants.skyEnabled == 1) {
        radiance += throughput * getSkyColor(direction);
      }
      break;
    }

    // レイがヒットしなかった or 最大深度に達したら終了
    if (prd.miss == 1 || prd.depth > pushConstants.maxRecursionDepth) {
      break;
    }

    Material material = prd.material;
    vec3 viewDirection = -direction;
    MaterialData materialData = getMaterialData(prd, material, viewDirection);

    // 最初のサンプルならnormalとbaseColorを出力する
    if (pushConstants.sampleIndex == 0 && prd.depth == 1) {
      outputNormal = materialData.shadingNormal;
      outputBaseColor = materialData.baseColor;
    }

    origin = prd.hitPosition;

    float russianRouletteProbability = clamp(luminance(throughput), 0.0, 1.0);
    if (prd.depth > 0) {
      float p = rnd();
      if (p > russianRouletteProbability) {
        break;
      }
      throughput /= russianRouletteProbability;
    }

    if (pushConstants.sunEnabled == 1) {
      // sun NEE
      vec3 sunStrength = getSunStrength();
      float[2] u2 = SAMPLE_RANDOM(2, 2, 3)(prd.depth);
      vec3 sunDirection = sampleSunDirection(u2);
      shadowPrd.shadow = 0;
      shadowPrd.transparent = vec3(1.0);
      traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                  0xff, // mask
                  3,    // sbtRecordOffset
                  1,    // sbtRecordStride
                  1,    // missIndex
                  origin, tmin, sunDirection, tmax,
                  1 // payload location
      );
      if (shadowPrd.shadow == 0 && isSunDirection(sunDirection)) {
        float sunPdf = getSunPdf(sunDirection);
        float skyPdf = getSkyPdf(sunDirection);
        vec3 bsdf =
            evalStandardBsdfNEE(prd, material, viewDirection, sunDirection);
        float bsdfPdf =
            evalStandardPdf(prd, material, viewDirection, sunDirection);
        float misWeight =
            misWeightPowerHeuristic(sunPdf, float[](sunPdf, 1.0, bsdfPdf));
        float cosTheta =
            max(dot(sunDirection, materialData.shadingNormal), 0.0);
        radiance += sunStrength * throughput * shadowPrd.transparent * bsdf *
                    cosTheta * misWeight / sunPdf;
      }
    }

    if (pushConstants.skyEnabled == 1) {
      // sky NEE
      float[2] u2 = SAMPLE_RANDOM(2, 2, 3)(prd.depth);
      vec3 skyDirection;
      float skyPdf;
      vec3 skyStrength;
      sampleSky(u2, skyDirection, skyPdf, skyStrength);
      shadowPrd.shadow = 0;
      shadowPrd.transparent = vec3(1.0);
      traceRayEXT(topLevelAS, gl_RayFlagsNoneEXT,
                  0xff, // mask
                  2,    // sbtRecordOffset
                  1,    // sbtRecordStride
                  1,    // missIndex
                  origin, tmin, skyDirection, tmax,
                  1 // payload location
      );
      if (shadowPrd.shadow == 0 && skyPdf != 0.0) {
        float sunPdf = getSunPdf(skyDirection);
        vec3 bsdf =
            evalStandardBsdfNEE(prd, material, viewDirection, skyDirection);
        float bsdfPdf =
            evalStandardPdf(prd, material, viewDirection, skyDirection);
        float misWeight =
            misWeightPowerHeuristic(skyPdf, float[](sunPdf, skyPdf, bsdfPdf));
        float cosTheta =
            max(dot(skyDirection, materialData.shadingNormal), 0.0);
        radiance += skyStrength * throughput * shadowPrd.transparent * bsdf *
                    cosTheta * misWeight / skyPdf;
      }
    }

    float[3] uu = SAMPLE_RANDOM(3, 3, 4)(prd.depth);
    SampleStandardBsdfResult result =
        sampleStandardBsdf(uu, prd, material, viewDirection);

    radiance += throughput * result.emissive;

    if (!result.traceNext) {
      break;
    }

    float sunPdf = 0.0;
    float skyPdf = 0.0;
    if (pushConstants.sunEnabled == 1) {
      sunPdf = getSunPdf(result.outDirection);
    }
    if (pushConstants.skyEnabled == 1) {
      skyPdf = getSkyPdf(result.outDirection);
    }

    float misWeight = misWeightPowerHeuristic(
        result.pdf, float[](sunPdf, skyPdf, result.pdf));

    direction = result.outDirection;
    throughput *= result.bsdf * result.cosTheta * misWeight / result.pdf;
  }

  vec3 rgb = radiance;
  if (isnan(rgb.x) || isnan(rgb.y) || isnan(rgb.z)) {
    return;
  }

  vec4 prev = imageLoad(storageReadImages[pushConstants.accumulateImageIndex],
                        ivec2(gl_LaunchIDEXT.xy));
  imageStore(storageWriteImages[pushConstants.accumulateImageIndex],
             ivec2(gl_LaunchIDEXT.xy), vec4(prev.rgb + rgb, 1.0));

  if (pushConstants.sampleIndex == 0) {
    imageStore(storageWriteImages[pushConstants.normalImageIndex],
               ivec2(gl_LaunchIDEXT.xy), vec4(outputNormal * 0.5 + 0.5, 1.0));
    imageStore(storageWriteImages[pushConstants.baseColorImageIndex],
               ivec2(gl_LaunchIDEXT.xy), vec4(outputBaseColor, 1.0));
  }
}
