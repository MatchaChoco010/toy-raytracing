#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "bxdf.glsl"
#include "common.glsl"
#include "payload.glsl"
#include "push_constants.glsl"
#include "random.glsl"

layout(location = 0) rayPayloadEXT Prd prd;

vec3 reinhardToneMapping(vec3 color) {
  return color / (color + vec3(1.0)) *
         (1 + color / (pushConstants.lWhite * pushConstants.lWhite));
}

vec3 gammaCorrection(vec3 color) { return pow(color, vec3(1.0 / 2.2)); }

void main() {
  init_random(0);

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  vec2 delta = rnd2() - vec2(0.5);
  vec2 inUV = (pixelCenter + delta) / vec2(gl_LaunchSizeEXT.xy);
  vec2 d = inUV * 2.0 - 1.0;
  d.x *= float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

  vec3 origin = pushConstants.cameraTranslate;
  vec3 direction = normalize(vec3(d.x, d.y, -2.0));
  direction = (pushConstants.cameraRotate * vec4(direction, 0.0)).xyz;
  float tmin = 0.001;
  float tmax = 100000.0;

  prd.depth = 0;
  vec3 radiance = vec3(0.0);
  vec3 throughput = vec3(1.0);

  prd.miss = 0;
  while (true) {
    traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT,
                0xff, // mask
                0,    // sbtRecordOffset
                0,    // sbtRecordStride
                0,    // missIndex
                origin, tmin, direction, tmax,
                0 // payload location
    );

    prd.depth++;
    if (prd.miss == 1 || prd.depth > pushConstants.maxRecursionDepth) {
      break;
    }

    float russianRouletteProbability = clamp(luminance(throughput), 0.0, 1.0);
    if (prd.depth > 0) {
      float p = rnd1();
      if (p > russianRouletteProbability) {
        break;
      }
      throughput /= russianRouletteProbability;
    }

    origin = prd.hitPosition;
    Material material = prd.material;

    vec3 viewDirection = -direction;
    vec3 dir;
    vec3 weight;
    vec3 emissive;
    bool traceNext =
        sampleStandardBrdf(prd, material, viewDirection, dir, weight, emissive);

    radiance += throughput * emissive;

    if (!traceNext) {
      break;
    }

    direction = dir;
    throughput *= weight;
  }

  vec3 rgb = radiance;

  vec4 prev = imageLoad(storageReadImages[pushConstants.storageImageIndex],
                        ivec2(gl_LaunchIDEXT.xy));
  imageStore(storageWriteImages[pushConstants.storageImageIndex],
             ivec2(gl_LaunchIDEXT.xy), vec4(prev.rgb + rgb, 1.0));
}
